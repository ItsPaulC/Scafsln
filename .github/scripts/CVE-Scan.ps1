param(
     [string]$initialDirectory = (Get-Location).Path
)

# Import the utility functions
$scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Path
$scanUtilityScriptPath = Join-Path -Path $scriptPath -ChildPath "Scan-Utilities.ps1"

# Check if the utility script exists and source it
if (-not (Test-Path -Path $scanUtilityScriptPath)) {
    Write-Error "Required utility script not found: $scanUtilityScriptPath"
    exit 1
}

# Dot source the utility script to import the functions
. $scanUtilityScriptPath

# Import the general utility functions
$generalUtilityScriptPath = Join-Path -Path $scriptPath -ChildPath "General-Utilities.ps1"

if (-not (Test-Path -Path $generalUtilityScriptPath)) {
    Write-Error "Required general utility script not found: $generalUtilityScriptPath"
    exit 1
}

. $generalUtilityScriptPath

#region Main Script

    ##########
    # Capture just the string return value
    $slnPath = (New-Solution-FromProjectPath -startDir $initialDirectory).Trim()
    #########################

    # List vulnerable packages in the solution
    Write-Host "Scanning packages for vulnerabilities..." -ForegroundColor Cyan
    $foundVulnerablePackages = [System.Collections.Generic.List[PSObject]]::new()

    # Run 'dotnet list package --vulnerable' command to check for vulnerabilities
    $packageListResult = dotnet list $slnPath package --vulnerable

    foreach ($line in $packageListResult) {
        # Check if line starts with '>' (after any whitespace)
        if ($line -match '^\s*>\s+(.+?)\s+(\S+)(?:\s+(\S+))?\s+(Critical|High)\s+(\S+.*)$') {
            $packageName = $matches[1].Trim()
            $firstVersion = $matches[2].Trim()
            
            # If there are two version numbers, use the second one (vulnerable version)
            # Otherwise use the first version
            $vulnerableVersion = if ($matches[3]) { $matches[3].Trim() } else { $firstVersion }
            
            # Only include Critical or High severity vulnerabilities
            $severity = $matches[4].Trim()
            $advisoryUrl = $matches[5].Trim()
            
            if ($severity -eq "Critical" -or $severity -eq "High") {
                $foundVulnerablePackages.Add([PSCustomObject]@{
                    PackageName = $packageName
                    Version = $vulnerableVersion
                    Severity = $severity
                    AdvisoryUrl = $advisoryUrl
                })
            }
        }
    }

    # Display vulnerable packages if any were found
    if ($foundVulnerablePackages.Count -gt 0) {
        Format-TableOutput -Data $foundVulnerablePackages -Title "High/Critical Vulnerabilities Found!" -TitleColor Red -RowColor Yellow
        
        # Fail the build becasue high or critical vulnerabilities were found
        exit 1
    }
    else {
        Write-Host "No high or critical vulnerabilities found." -ForegroundColor Green
    }

#endregion Main Script
